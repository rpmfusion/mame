diff -up mame-0.165/3rdparty/genie/src/actions/make/make_cpp.lua.smpfix mame-0.165/3rdparty/genie/src/actions/make/make_cpp.lua
--- mame-0.165/3rdparty/genie/src/actions/make/make_cpp.lua.smpfix	2015-08-27 07:40:57.482675363 +0200
+++ mame-0.165/3rdparty/genie/src/actions/make/make_cpp.lua	2015-08-27 07:40:57.784684098 +0200
@@ -86,7 +86,7 @@
 		end
 
 		-- target build rule
-		_p('$(TARGET): $(GCH) $(OBJECTS) $(LDDEPS) $(RESOURCES)')
+		_p('$(TARGET): $(TARGETDIR) $(OBJDIRS) $(GCH) $(OBJECTS) $(LDDEPS) $(RESOURCES)')
 
 		if prj.kind == "StaticLib" then
 			if prj.msgarchiving then
diff -up mame-0.165/3rdparty/genie/src/host/scripts.c.smpfix mame-0.165/3rdparty/genie/src/host/scripts.c
--- mame-0.165/3rdparty/genie/src/host/scripts.c.smpfix	2015-08-27 07:40:57.785684127 +0200
+++ mame-0.165/3rdparty/genie/src/host/scripts.c	2015-08-29 06:25:33.824898451 +0200
@@ -55,10 +55,10 @@ const char* builtin_scripts[] = {
 	"roject.getbasename(prjname, pattern)\nreturn pattern:gsub(\"%%%%\", prjname)\nend\nfunction premake.project.getfilename(prj, pattern)\nlocal fname = premake.project.getbasename(prj.name, pattern)\nfname = path.join(prj.location, fname)\nreturn path.getrelative(os.getcwd(), fname)\nend\n function premake.getlinks(cfg, kind, part)\nlocal result = iif (part == \"directory\" and kind == \"all\", cfg.libdirs, {})\nlocal cfgname = iif(cfg.name == cfg.project.name, \"\", cfg.name)\nlocal pathstyle = premake.getpathstyle(cfg)\nlocal namestyle = premake.getnamestyle(cfg)\nlocal function canlink(source, target)\nif (target.kind ~= \"SharedLib\" and target.kind ~= \"StaticLib\") then\nreturn false\nend\nif premake.iscppproject(source) then\nreturn premake.iscppproject(target)\nelseif premake.isdotnetproject(source) then\nreturn premake.isdotnetproject(target)\nend\nend\nfor _, link in ipairs(cfg.links) do\nlocal item\nlocal prj = premake.findproject(link)\nif prj and kind ~= \"system\" then\nlocal prjcfg = premake.getcon"
 	"fig(prj, cfgname, cfg.platform)\nif kind == \"dependencies\" or canlink(cfg, prjcfg) then\nif (part == \"directory\") then\nitem = path.rebase(prjcfg.linktarget.directory, prjcfg.location, cfg.location)\nelseif (part == \"basename\") then\nitem = prjcfg.linktarget.basename\nelseif (part == \"fullpath\") then\nitem = path.rebase(prjcfg.linktarget.fullpath, prjcfg.location, cfg.location)\nelseif (part == \"object\") then\nitem = prjcfg\nend\nend\nelseif not prj and (kind == \"system\" or kind == \"all\") then\nif (part == \"directory\") then\nitem = path.getdirectory(link)\nelseif (part == \"fullpath\") then\nitem = link\nif namestyle == \"windows\" then\nif premake.iscppproject(cfg) then\nitem = item .. \".lib\"\nelseif premake.isdotnetproject(cfg) then\nitem = item .. \".dll\"\nend\nend\nelseif part == \"name\" then\nitem = path.getname(link)\nelseif part == \"basename\" then\nitem = path.getbasename(link)\nelse\nitem = link\nend\nif item:find(\"/\", nil, true) then\nitem = path.getrelative(cfg.project.locatio"
 	"n, item)\nend\nend\nif item then\nif pathstyle == \"windows\" and part ~= \"object\" then\nitem = path.translate(item, \"\\\\\")\nend\nif not table.contains(result, item) then\ntable.insert(result, item)\nend\nend\nend\nreturn result\nend\nfunction premake.getnamestyle(cfg)\nreturn premake.platforms[cfg.platform].namestyle or premake.gettool(cfg).namestyle or \"posix\"\nend\nfunction premake.getpathstyle(cfg)\nif premake.action.current().os == \"windows\" then\nreturn \"windows\"\nelse\nreturn \"posix\"\nend\nend\nfunction premake.gettarget(cfg, direction, pathstyle, namestyle, system)\nif system == \"bsd\" then\nsystem = \"linux\"\nend\nlocal kind = cfg.kind\nif premake.iscppproject(cfg) then\nif (namestyle == \"windows\" or system == \"windows\")\nand kind == \"SharedLib\" and direction == \"link\"\nand not cfg.flags.NoImportLib\nthen\nkind = \"StaticLib\"\nend\nif namestyle == \"posix\" and system == \"windows\" and kind ~= \"StaticLib\" then\nnamestyle = \"windows\"\nend\nend\nlocal field   = \"build\"\nif"
-	" direction == \"link\" and cfg.kind == \"SharedLib\" then\nfield = \"implib\"\nend\nlocal name    = cfg[field..\"name\"] or cfg.targetname or cfg.project.name\nlocal dir     = cfg[field..\"dir\"] or cfg.targetdir or path.getrelative(cfg.location, cfg.basedir)\nlocal subdir  = cfg[field..\"subdir\"] or cfg.targetsubdir or \".\"\nlocal prefix  = \"\"\nlocal suffix  = \"\"\nlocal ext     = \"\"\nlocal bundlepath, bundlename\ndir = path.join(dir, subdir)\nif namestyle == \"windows\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\next = \".exe\"\nelseif kind == \"SharedLib\" then\next = \".dll\"\nelseif kind == \"StaticLib\" then\next = \".lib\"\nend\nelseif namestyle == \"posix\" then\nif kind == \"WindowedApp\" and system == \"macosx\" then\nbundlename = name .. \".app\"\nbundlepath = path.join(dir, bundlename)\ndir = path.join(bundlepath, \"Contents/MacOS\")\nelseif (kind == \"ConsoleApp\" or kind == \"WindowedApp\") and system == \"os2\" then ext = \".exe\"\nelseif kind == \"SharedLib\" then\np"
-	"refix = \"lib\"\next = iif(system == \"macosx\", \".dylib\", \".so\")\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\next = \".a\"\nend\nelseif namestyle == \"PS3\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\next = \".elf\"\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\next = \".a\"\nend\nelseif namestyle == \"Orbis\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\next = \".elf\"\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\next = \".a\"\nend\nend\nprefix = cfg[field..\"prefix\"] or cfg.targetprefix or prefix\nsuffix = cfg[field..\"suffix\"] or cfg.targetsuffix or suffix\next    = cfg[field..\"extension\"] or cfg.targetextension or ext\nlocal result = { }\nresult.basename     = name .. suffix\nresult.name         = prefix .. name .. suffix .. ext\nresult.directory    = dir\nresult.subdirectory = subdir\nresult.prefix       = prefix\nresult.suffix       = suffix\nresult.fullpath     = path.join(result.directory, result.name)\nresult.bundlepath   = bundl"
-	"epath or result.fullpath\nif pathstyle == \"windows\" then\nresult.directory    = path.translate(result.directory, \"\\\\\")\nresult.subdirectory = path.translate(result.subdirectory, \"\\\\\")\nresult.fullpath     = path.translate(result.fullpath,  \"\\\\\")\nend\nreturn result\nend\nfunction premake.gettool(cfg)\nif premake.iscppproject(cfg) then\nif _OPTIONS.cc then\nreturn premake[_OPTIONS.cc]\nend\nlocal action = premake.action.current()\nif action.valid_tools then\nreturn premake[action.valid_tools.cc[1]]\nend\nreturn premake.gcc\nelse\nreturn premake.dotnet\nend\nend\nfunction premake.project.getvpath(prj, abspath)\nlocal vpath = abspath\nlocal fname = path.getname(abspath)\nlocal max = abspath:len() - fname:len()\nfor replacement, patterns in pairs(prj.vpaths or {}) do\nfor _, pattern in ipairs(patterns) do\nlocal i = abspath:find(path.wildcards(pattern))\nif i == 1 then\ni = pattern:find(\"*\", 1, true) or (pattern:len() + 1)\nlocal leaf\nif i < max then\nleaf = abspath:sub(i)\nelse\nleaf = fname\nend"
-	"\nif leaf:startswith(\"/\") then\nleaf = leaf:sub(2)\nend\nlocal stem = \"\"\nif replacement:len() > 0 then\nstem, stars = replacement:gsub(\"%*\", \"\")\nif stars == 0 then\nleaf = path.getname(leaf)\nend\nelse\nleaf = path.getname(leaf)\nend\nvpath = path.join(stem, leaf)\nend\nend\nend\nreturn path.trimdots(vpath)\nend\nfunction premake.hascppproject(sln)\nfor prj in premake.solution.eachproject(sln) do\nif premake.iscppproject(prj) then\nreturn true\nend\nend\nend\nfunction premake.hasdotnetproject(sln)\nfor prj in premake.solution.eachproject(sln) do\nif premake.isdotnetproject(prj) then\nreturn true\nend\nend\nend\nfunction premake.project.iscproject(prj)\nreturn prj.language == \"C\"\nend\nfunction premake.iscppproject(prj)\nreturn (prj.language == \"C\" or prj.language == \"C++\")\nend\nfunction premake.isdotnetproject(prj)\nreturn (prj.language == \"C#\")\nend\n",
+	" direction == \"link\" and cfg.kind == \"SharedLib\" then\nfield = \"implib\"\nend\nlocal name    = cfg[field..\"name\"] or cfg.targetname or cfg.project.name\nlocal dir     = cfg[field..\"dir\"] or cfg.targetdir or path.getrelative(cfg.location, cfg.basedir)\nlocal subdir  = cfg[field..\"subdir\"] or cfg.targetsubdir or \".\"\nlocal prefix  = \"\"\nlocal suffix  = \"\"\nlocal ext     = \"\"\nlocal bundlepath, bundlename\ndir = path.join(dir, subdir)\nif namestyle == \"windows\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\next = \".exe\"\nelseif kind == \"SharedLib\" then\next = \".dll\"\nelseif kind == \"StaticLib\" then\next = \".lib\"\nend\nelseif namestyle == \"posix\" then\nif kind == \"WindowedApp\" and system == \"macosx\" then\nbundlename = name .. \".app\"\nbundlepath = path.join(dir, bundlename)\ndir = path.join(bundlepath, \"Contents/MacOS\")\nelseif (kind == \"ConsoleApp\" or kind == \"WindowedApp\") and system == \"os2\" then\next = \".exe\"\nelseif kind == \"SharedLib\" then\n"
+	"prefix = \"lib\"\next = iif(system == \"macosx\", \".dylib\", \".so\")\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\next = \".a\"\nend\nelseif namestyle == \"PS3\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\next = \".elf\"\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\next = \".a\"\nend\nelseif namestyle == \"Orbis\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\next = \".elf\"\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\next = \".a\"\nend\nend\nprefix = cfg[field..\"prefix\"] or cfg.targetprefix or prefix\nsuffix = cfg[field..\"suffix\"] or cfg.targetsuffix or suffix\next    = cfg[field..\"extension\"] or cfg.targetextension or ext\nlocal result = { }\nresult.basename     = name .. suffix\nresult.name         = prefix .. name .. suffix .. ext\nresult.directory    = dir\nresult.subdirectory = subdir\nresult.prefix       = prefix\nresult.suffix       = suffix\nresult.fullpath     = path.join(result.directory, result.name)\nresult.bundlepath   = bund"
+	"lepath or result.fullpath\nif pathstyle == \"windows\" then\nresult.directory    = path.translate(result.directory, \"\\\\\")\nresult.subdirectory = path.translate(result.subdirectory, \"\\\\\")\nresult.fullpath     = path.translate(result.fullpath,  \"\\\\\")\nend\nreturn result\nend\nfunction premake.gettool(cfg)\nif premake.iscppproject(cfg) then\nif _OPTIONS.cc then\nreturn premake[_OPTIONS.cc]\nend\nlocal action = premake.action.current()\nif action.valid_tools then\nreturn premake[action.valid_tools.cc[1]]\nend\nreturn premake.gcc\nelse\nreturn premake.dotnet\nend\nend\nfunction premake.project.getvpath(prj, abspath)\nlocal vpath = abspath\nlocal fname = path.getname(abspath)\nlocal max = abspath:len() - fname:len()\nfor replacement, patterns in pairs(prj.vpaths or {}) do\nfor _, pattern in ipairs(patterns) do\nlocal i = abspath:find(path.wildcards(pattern))\nif i == 1 then\ni = pattern:find(\"*\", 1, true) or (pattern:len() + 1)\nlocal leaf\nif i < max then\nleaf = abspath:sub(i)\nelse\nleaf = fname\nen"
+	"d\nif leaf:startswith(\"/\") then\nleaf = leaf:sub(2)\nend\nlocal stem = \"\"\nif replacement:len() > 0 then\nstem, stars = replacement:gsub(\"%*\", \"\")\nif stars == 0 then\nleaf = path.getname(leaf)\nend\nelse\nleaf = path.getname(leaf)\nend\nvpath = path.join(stem, leaf)\nend\nend\nend\nreturn path.trimdots(vpath)\nend\nfunction premake.hascppproject(sln)\nfor prj in premake.solution.eachproject(sln) do\nif premake.iscppproject(prj) then\nreturn true\nend\nend\nend\nfunction premake.hasdotnetproject(sln)\nfor prj in premake.solution.eachproject(sln) do\nif premake.isdotnetproject(prj) then\nreturn true\nend\nend\nend\nfunction premake.project.iscproject(prj)\nreturn prj.language == \"C\"\nend\nfunction premake.iscppproject(prj)\nreturn (prj.language == \"C\" or prj.language == \"C++\")\nend\nfunction premake.isdotnetproject(prj)\nreturn (prj.language == \"C#\")\nend\n",
 
 	/* base/config.lua */
 	"premake.config = { }\nlocal config = premake.config\nfunction premake.config.isdebugbuild(cfg)\nif cfg.flags.Optimize or cfg.flags.OptimizeSize or cfg.flags.OptimizeSpeed then\nreturn false\nend\nif not cfg.flags.Symbols then\nreturn false\nend\nreturn true\nend\nfunction premake.config.isincrementallink(cfg)\nif cfg.kind == \"StaticLib\" \nor config.isoptimizedbuild(cfg.flags)\nor cfg.flags.NoIncrementalLink then\nreturn false\nend\nreturn true\nend\nfunction premake.config.isoptimizedbuild(flags)\nreturn flags.Optimize or flags.OptimizeSize or flags.OptimizeSpeed\nend\n",
@@ -180,18 +180,18 @@ const char* builtin_scripts[] = {
 
 	/* actions/make/make_cpp.lua */
 	"premake.make.cpp = { }\npremake.make.override = { }\nlocal cpp = premake.make.cpp\nlocal make = premake.make\nfunction premake.make_cpp(prj)\nlocal cc = premake.gettool(prj)\nlocal platforms = premake.filterplatforms(prj.solution, cc.platforms, \"Native\")\npremake.gmake_cpp_header(prj, cc, platforms)\nfor _, platform in ipairs(platforms) do\nfor cfg in premake.eachconfig(prj, platform) do\npremake.gmake_cpp_config(prj, cfg, cc)\nend\nend\nlocal objdirs = {}\nlocal additionalobjdirs = {}\nfor _, file in ipairs(prj.files) do\nif path.iscppfile(file) then\nobjdirs[_MAKE.esc(path.getdirectory(path.trimdots(file)))] = 1\nend\nend\nfor _, custombuildtask in ipairs(prj.custombuildtask or {}) do\nfor _, buildtask in ipairs(custombuildtask or {}) do\nadditionalobjdirs[_MAKE.esc(path.getdirectory(path.getrelative(prj.location,buildtask[2])))] = 1\nend\nend\n_p('OBJDIRS := \\\\')\n_p('\\t$(OBJDIR) \\\\')\nfor dir, _ in pairs(objdirs) do\n_p('\\t$(OBJDIR)/%s \\\\', dir)\nend\nfor dir, _ in pairs(additionalobjdirs) do\n_p"
-	"('\\t%s \\\\', dir)\nend\n_p('')\n_p('RESOURCES := \\\\')\nfor _, file in ipairs(prj.files) do\nif path.isresourcefile(file) then\n_p('\\t$(OBJDIR)/%s.res \\\\', _MAKE.esc(path.getbasename(file)))\nend\nend\n_p('')\n_p('.PHONY: clean prebuild prelink')\n_p('')\nif os.is(\"MacOSX\") and prj.kind == \"WindowedApp\" then\n_p('all: $(TARGETDIR) $(OBJDIRS) prebuild prelink $(TARGET) $(dir $(TARGETDIR))PkgInfo $(dir $(TARGETDIR))Info.plist')\nelse\n_p('all: $(TARGETDIR) $(OBJDIRS) prebuild prelink $(TARGET)')\nend\n_p('\\t@:')\n_p('')\nif (prj.kind == \"StaticLib\" and prj.options.ArchiveSplit) then\n_p('define max_args')\n_p('\\t$(eval _args:=)')\n_p('\\t$(foreach obj,$3,$(eval _args+=$(obj))$(if $(word $2,$(_args)),$1$(_args)$(EOL)$(eval _args:=)))')\n_p('\\t$(if $(_args),$1$(_args))')\n_p('endef')\n_p('')\n_p('define EOL')\n_p('')\n_p('')\n_p('endef')\n_p('')\nend\n_p('$(TARGET): $(GCH) $(OBJECTS) $(LDDEPS) $(RESOURCES)')\nif prj.kind == \"StaticLib\" then\nif prj.msgarchiving then\n_p('\\t@echo ' .. prj.msgarchi"
-	"ving)\nelse\n_p('\\t@echo Archiving %s', prj.name)\nend\nif (not prj.archivesplit_size) then\nprj.archivesplit_size=200\nend\nif (not prj.options.ArchiveSplit) then\n_p('\\t$(SILENT) $(LINKCMD) $(OBJECTS)')\nelse\n_p('\\t$(call RM,$(TARGET))')\n_p('\\t@$(call max_args,$(LINKCMD),'.. prj.archivesplit_size ..',$(OBJECTS))')\n_p('\\t$(SILENT) $(LINKCMD_NDX)')\nend\nelse\nif prj.msglinking then\n_p('\\t@echo ' .. prj.msglinking)\nelse\n_p('\\t@echo Linking %s', prj.name)\nend\n_p('\\t$(SILENT) $(LINKCMD)')\nend\n_p('\\t$(POSTBUILDCMDS)')\n_p('')\n_p('$(TARGETDIR):')\npremake.make_mkdirrule(\"$(TARGETDIR)\")\n_p('$(OBJDIRS):')\nif (not prj.solution.messageskip) or (not table.contains(prj.solution.messageskip, \"SkipCreatingMessage\")) then\n_p('\\t@echo Creating $(@)')\nend\n_p('\\t-$(call MKDIR,$@)')\n_p('')\nif os.is(\"MacOSX\") and prj.kind == \"WindowedApp\" then\n_p('$(dir $(TARGETDIR))PkgInfo:')\n_p('$(dir $(TARGETDIR))Info.plist:')\n_p('')\nend\n_p('clean:')\nif (not prj.solution.messageskip) or (not table.c"
-	"ontains(prj.solution.messageskip, \"SkipCleaningMessage\")) then\n_p('\\t@echo Cleaning %s', prj.name)\nend\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('\\t$(SILENT) rm -f  $(TARGET)')\n_p('\\t$(SILENT) rm -rf $(OBJDIR)')\n_p('else')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(TARGET)) del $(subst /,\\\\\\\\,$(TARGET))')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\\\\\,$(OBJDIR))')\n_p('endif')\n_p('')\n_p('prebuild:')\n_p('\\t$(PREBUILDCMDS)')\n_p('')\n_p('prelink:')\n_p('\\t$(PRELINKCMDS)')\n_p('')\ncpp.pchrules(prj)\ncpp.fileRules(prj)\ncpp.dependencyRules(prj)\nfor _, custombuildtask in ipairs(prj.custombuildtask or {}) do\nfor _, buildtask in ipairs(custombuildtask or {}) do\nlocal deps =  string.format(\"%s \",path.getrelative(prj.location,buildtask[1]))\nfor _, depdata in ipairs(buildtask[3] or {}) do\ndeps = deps .. string.format(\"%s \",path.getrelative(prj.location,depdata))\nend\n_p('%s: %s'\n,path.getrelative(prj.location,buildtask[2])\n, deps\n)\nfor _, cmdline "
-	"in ipairs(buildtask[4] or {}) do\nlocal cmd = cmdline\nlocal num = 1\nfor _, depdata in ipairs(buildtask[3] or {}) do\ncmd = string.gsub(cmd,\"%$%(\" .. num ..\"%)\", string.format(\"%s \",path.getrelative(prj.location,depdata)))\nnum = num + 1\nend\ncmd = string.gsub(cmd, \"%$%(<%)\", \"$<\")\ncmd = string.gsub(cmd, \"%$%(@%)\", \"$@\")\n \n_p('\\t$(SILENT) %s',cmd)\nend\n_p('')\nend\nend\n_p('-include $(OBJECTS:%%.o=%%.d)')\n_p('ifneq (,$(PCH))')\n_p('  -include $(OBJDIR)/$(notdir $(PCH)).d')\n_p('endif')\nend\nfunction premake.gmake_cpp_header(prj, cc, platforms)\n_p('# %s project makefile autogenerated by GENie', premake.action.current().shortname)\n_p('ifndef config')\n_p('  config=%s', _MAKE.esc(premake.getconfigname(prj.solution.configurations[1], platforms[1], true)))\n_p('endif')\n_p('')\n_p('ifndef verbose')\n_p('  SILENT = @')\n_p('endif')\n_p('')\n_p('SHELLTYPE := msdos')\n_p('ifeq (,$(ComSpec)$(COMSPEC))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(SHELL)))')\n_p("
-	"'  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(MAKESHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('')\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('  MKDIR = $(SILENT) mkdir -p \"$(1)\"')\n_p('  COPY  = $(SILENT) cp -fR \"$(1)\" \"$(2)\"')\n_p('  RM= $(SILENT) rm -f \"$(1)\"')\n_p('else')\n_p('  MKDIR = $(SILENT) mkdir \"$(subst /,\\\\\\\\,$(1))\" 2> nul || exit 0')\n_p('  COPY  = $(SILENT) copy /Y \"$(subst /,\\\\\\\\,$(1))\" \"$(subst /,\\\\\\\\,$(2))\"')\n_p('  RM    = $(SILENT) del /F \"$(subst /,\\\\\\\\,$(1))\" 2> nul || exit 0')\n_p('endif')\n_p('')\n_p('CC  = %s', cc.cc)\n_p('CXX = %s', cc.cxx)\n_p('AR  = %s', cc.ar)\n_p('')\n_p('ifndef RESCOMP')\n_p('  ifdef WINDRES')\n_p('    RESCOMP = $(WINDRES)')\n_p('  else')\n_p('    RESCOMP = windres')\n_p('  endif')\n_p('endif')\n_p('')\nend\nfunction premake.gmake_cpp_config(prj, cfg, cc)\n_p('ifeq ($(config),%s)', _MAKE.esc(cfg.shortname))\ncpp.platformtools(cfg, cc)\n_p('  ' .. (table.contains(premake.make.override,\"OBJDIR\") and "
-	"\"override \" or \"\") ..    'OBJDIR     = %s', _MAKE.esc(cfg.objectsdir))\n_p('  ' .. (table.contains(premake.make.override,\"TARGETDIR\") and \"override \" or \"\") .. 'TARGETDIR  = %s', _MAKE.esc(cfg.buildtarget.directory))\n_p('  ' .. (table.contains(premake.make.override,\"TARGET\") and \"override \" or \"\") ..    'TARGET     = $(TARGETDIR)/%s', _MAKE.esc(cfg.buildtarget.name))\n_p('  DEFINES   +=%s', make.list(cc.getdefines(cfg.defines)))\n_p('  INCLUDES  +=%s', make.list(cc.getincludedirs(cfg.includedirs)))\ncpp.pchconfig(cfg)\ncpp.flags(cfg, cc)\ncpp.linker(prj, cfg, cc)\n_p('  OBJECTS := \\\\')\nfor _, file in ipairs(prj.files) do\nif path.iscppfile(file) then\nif not table.icontains(cfg.excludes, file) then\n_p('\\t$(OBJDIR)/%s.o \\\\'\n, _MAKE.esc(path.trimdots(path.removeext(file)))\n)\nend\nend\nend\n_p('')\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p(' "
-	" endef')\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p('\\t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\nmake.settings(cfg, cc)\n_p('endif')\n_p('')\nend\nfunction cpp.platformtools(cfg, cc)\nlocal platform = cc.platforms[cfg.platform]\nif platform.cc then\n_p('  CC         = %s', platform.cc)\nend\nif platform.cxx then\n_p('  CXX        = %s', platform.cxx)\nend\nif platform.ar then\n_p('  AR         = %s', platform.ar)\nend\nend\nfunction cpp.flags(cfg, cc)\nif cfg.pchheader and not cfg.flags.NoPCH then\n_p('  FORCE_INCLUDE += -include $(OBJDIR)/$(notdir $(PCH))')\nend\nif #cfg.forcedincludes > 0 then\n_p('  FORCE_INCLUDE += -include %s'\n,premake.esc(table.concat(cfg.forcedincludes, \";\")))\nend\n_p('  AL"
-	"L_CPPFLAGS  += $(CPPFLAGS) %s $(DEFINES) $(INCLUDES)', table.concat(cc.getcppflags(cfg), \" \"))\n_p('  ALL_CFLAGS    += $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)%s', make.list(table.join(cc.getcflags(cfg), cfg.buildoptions, cfg.buildoptions_c)))\n_p('  ALL_CXXFLAGS  += $(CXXFLAGS) $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)%s', make.list(table.join(cc.getcflags(cfg), cc.getcxxflags(cfg), cfg.buildoptions, cfg.buildoptions_cpp)))\n_p('  ALL_OBJCFLAGS += $(CXXFLAGS) $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)%s', make.list(table.join(cc.getcflags(cfg), cc.getcxxflags(cfg), cfg.buildoptions, cfg.buildoptions_objc)))\n_p('  ALL_RESFLAGS  += $(RESFLAGS) $(DEFINES) $(INCLUDES)%s',\n        make.list(table.join(cc.getdefines(cfg.resdefines),\n                                cc.getincludedirs(cfg.resincludedirs), cfg.resoptions)))\nend\nfunction cpp.linker(prj, cfg, cc)\n_p('  ALL_LDFLAGS   += $(LDFLAGS)%s', make.list(table.join(cc.getlibdirflags(cfg), cc.getldflags(cfg), cfg.linkoptions)))\n_p('  LDDEPS    +=%s', make.list(_MAKE.esc(premake.ge"
-	"tlinks(cfg, \"siblings\", \"fullpath\"))))\n_p('  LIBS      += $(LDDEPS)%s', make.list(cc.getlinkflags(cfg)))\nif cfg.kind == \"StaticLib\" then\nif cfg.platform:startswith(\"Universal\") then\n_p('  LINKCMD    = libtool -o $(TARGET)')\nelse\nif (not prj.options.ArchiveSplit) then\nif cc.llvm then\n_p('  LINKCMD    = $(AR) rcs $(TARGET)')\nelse\n_p('  LINKCMD    = $(AR) -rcs $(TARGET)')\nend\nelse\nif cc.llvm then\n_p('  LINKCMD    = $(AR) qc $(TARGET)')\n_p('  LINKCMD_NDX= $(AR) cs $(TARGET)')\nelse\n_p('  LINKCMD    = $(AR) -qc $(TARGET)')\n_p('  LINKCMD_NDX= $(AR) -cs $(TARGET)')\nend\nend\nend\nelse\nlocal tool = iif(cfg.language == \"C\", \"CC\", \"CXX\")\n_p('  LINKCMD    = $(%s) -o $(TARGET) $(OBJECTS) $(RESOURCES) $(ARCH) $(ALL_LDFLAGS) $(LIBS)', tool)\nend\nend\nfunction cpp.pchconfig(cfg)\nif not cfg.pchheader or cfg.flags.NoPCH then\nreturn\nend\nlocal pch = cfg.pchheader\nfor _, incdir in ipairs(cfg.includedirs) do\nlocal abspath = path.getabsolute(path.join(cfg.project.location, incdir))\nlocal te"
-	"stname = path.join(abspath, pch)\nif os.isfile(testname) then\npch = path.getrelative(cfg.location, testname)\nbreak\nend\nend\n_p('  PCH        = %s', _MAKE.esc(pch))\n_p('  GCH        = $(OBJDIR)/$(notdir $(PCH)).gch')\nend\nfunction cpp.pchrules(prj)\n_p('ifneq (,$(PCH))')\n_p('$(GCH): $(PCH)')\n_p('\\t@echo $(notdir $<)')\nlocal cmd = iif(prj.language == \"C\", \"$(CC) -x c-header $(ALL_CFLAGS)\", \"$(CXX) -x c++-header $(ALL_CXXFLAGS)\")\n_p('\\t$(SILENT) %s -MMD -MP $(DEFINES) $(INCLUDES) -o \"$@\" -MF \"$(@:%%.gch=%%.d)\" -c \"$<\"', cmd)\n_p('endif')\n_p('')\nend\nfunction cpp.fileRules(prj)\nfor _, file in ipairs(prj.files or {}) do\nif path.iscppfile(file) then\n_p('$(OBJDIR)/%s.o: %s'\n, _MAKE.esc(path.trimdots(path.removeext(file)))\n, _MAKE.esc(file)\n)\nif (path.isobjcfile(file) and prj.msgcompile_objc) then\n_p('\\t@echo ' .. prj.msgcompile_objc)\nelseif prj.msgcompile then\n_p('\\t@echo ' .. prj.msgcompile)\nelse\n_p('\\t@echo $(notdir $<)')\nend\nif (path.isobjcfile(file)) then\n_p('\\t$(SILEN"
-	"T) $(CXX) $(ALL_OBJCFLAGS) $(FORCE_INCLUDE) -o \"$@\" -MF $(@:%%.o=%%.d) -c \"$<\"')\nelse\ncpp.buildcommand(path.iscfile(file) and not prj.options.ForceCPP, \"o\")\nend\nfor _, task in ipairs(prj.postcompiletasks or {}) do\n_p('\\t$(SILENT) %s', task)\n_p('')\nend\n_p('')\nelseif (path.getextension(file) == \".rc\") then\n_p('$(OBJDIR)/%s.res: %s', _MAKE.esc(path.getbasename(file)), _MAKE.esc(file))\nif prj.msgresource then\n_p('\\t@echo ' .. prj.msgresource)\nelse\n_p('\\t@echo $(notdir $<)')\nend\n_p('\\t$(SILENT) $(RESCOMP) $< -O coff -o \"$@\" $(ALL_RESFLAGS)')\n_p('')\nend\nend\nend\nfunction cpp.dependencyRules(prj)\nfor _, dependency in ipairs(prj.dependency or {}) do\nfor _, dep in ipairs(dependency or {}) do\nif (dep[3]==nil or dep[3]==false) then\n_p('$(OBJDIR)/%s.o: %s'\n, _MAKE.esc(path.trimdots(path.removeext(path.getrelative(prj.location, dep[1]))))\n, _MAKE.esc(path.getrelative(prj.location, dep[2]))\n)\nelse\n_p('%s: %s'\n, _MAKE.esc(dep[1])\n, _MAKE.esc(path.getrelative(prj.location, dep[2]))"
-	"\n)\nend\n_p('')\nend\nend\nend\nfunction cpp.buildcommand(iscfile, objext)\nlocal flags = iif(iscfile, '$(CC) $(ALL_CFLAGS)', '$(CXX) $(ALL_CXXFLAGS)')\n_p('\\t$(SILENT) %s $(FORCE_INCLUDE) -o \"$@\" -MF $(@:%%.%s=%%.d) -c \"$<\"', flags, objext)\nend\n",
+	"('\\t%s \\\\', dir)\nend\n_p('')\n_p('RESOURCES := \\\\')\nfor _, file in ipairs(prj.files) do\nif path.isresourcefile(file) then\n_p('\\t$(OBJDIR)/%s.res \\\\', _MAKE.esc(path.getbasename(file)))\nend\nend\n_p('')\n_p('.PHONY: clean prebuild prelink')\n_p('')\nif os.is(\"MacOSX\") and prj.kind == \"WindowedApp\" then\n_p('all: $(TARGETDIR) $(OBJDIRS) prebuild prelink $(TARGET) $(dir $(TARGETDIR))PkgInfo $(dir $(TARGETDIR))Info.plist')\nelse\n_p('all: $(TARGETDIR) $(OBJDIRS) prebuild prelink $(TARGET)')\nend\n_p('\\t@:')\n_p('')\nif (prj.kind == \"StaticLib\" and prj.options.ArchiveSplit) then\n_p('define max_args')\n_p('\\t$(eval _args:=)')\n_p('\\t$(foreach obj,$3,$(eval _args+=$(obj))$(if $(word $2,$(_args)),$1$(_args)$(EOL)$(eval _args:=)))')\n_p('\\t$(if $(_args),$1$(_args))')\n_p('endef')\n_p('')\n_p('define EOL')\n_p('')\n_p('')\n_p('endef')\n_p('')\nend\n_p('$(TARGET): $(TARGETDIR) $(OBJDIRS) $(GCH) $(OBJECTS) $(LDDEPS) $(RESOURCES)')\nif prj.kind == \"StaticLib\" then\nif prj.msgarchiving then\n_p('"
+	"\\t@echo ' .. prj.msgarchiving)\nelse\n_p('\\t@echo Archiving %s', prj.name)\nend\nif (not prj.archivesplit_size) then\nprj.archivesplit_size=200\nend\nif (not prj.options.ArchiveSplit) then\n_p('\\t$(SILENT) $(LINKCMD) $(OBJECTS)')\nelse\n_p('\\t$(call RM,$(TARGET))')\n_p('\\t@$(call max_args,$(LINKCMD),'.. prj.archivesplit_size ..',$(OBJECTS))')\n_p('\\t$(SILENT) $(LINKCMD_NDX)')\nend\nelse\nif prj.msglinking then\n_p('\\t@echo ' .. prj.msglinking)\nelse\n_p('\\t@echo Linking %s', prj.name)\nend\n_p('\\t$(SILENT) $(LINKCMD)')\nend\n_p('\\t$(POSTBUILDCMDS)')\n_p('')\n_p('$(TARGETDIR):')\npremake.make_mkdirrule(\"$(TARGETDIR)\")\n_p('$(OBJDIRS):')\nif (not prj.solution.messageskip) or (not table.contains(prj.solution.messageskip, \"SkipCreatingMessage\")) then\n_p('\\t@echo Creating $(@)')\nend\n_p('\\t-$(call MKDIR,$@)')\n_p('')\nif os.is(\"MacOSX\") and prj.kind == \"WindowedApp\" then\n_p('$(dir $(TARGETDIR))PkgInfo:')\n_p('$(dir $(TARGETDIR))Info.plist:')\n_p('')\nend\n_p('clean:')\nif (not prj.solution.me"
+	"ssageskip) or (not table.contains(prj.solution.messageskip, \"SkipCleaningMessage\")) then\n_p('\\t@echo Cleaning %s', prj.name)\nend\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('\\t$(SILENT) rm -f  $(TARGET)')\n_p('\\t$(SILENT) rm -rf $(OBJDIR)')\n_p('else')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(TARGET)) del $(subst /,\\\\\\\\,$(TARGET))')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\\\\\,$(OBJDIR))')\n_p('endif')\n_p('')\n_p('prebuild:')\n_p('\\t$(PREBUILDCMDS)')\n_p('')\n_p('prelink:')\n_p('\\t$(PRELINKCMDS)')\n_p('')\ncpp.pchrules(prj)\ncpp.fileRules(prj)\ncpp.dependencyRules(prj)\nfor _, custombuildtask in ipairs(prj.custombuildtask or {}) do\nfor _, buildtask in ipairs(custombuildtask or {}) do\nlocal deps =  string.format(\"%s \",path.getrelative(prj.location,buildtask[1]))\nfor _, depdata in ipairs(buildtask[3] or {}) do\ndeps = deps .. string.format(\"%s \",path.getrelative(prj.location,depdata))\nend\n_p('%s: %s'\n,path.getrelative(prj.location,buildtask[2])\n"
+	", deps\n)\nfor _, cmdline in ipairs(buildtask[4] or {}) do\nlocal cmd = cmdline\nlocal num = 1\nfor _, depdata in ipairs(buildtask[3] or {}) do\ncmd = string.gsub(cmd,\"%$%(\" .. num ..\"%)\", string.format(\"%s \",path.getrelative(prj.location,depdata)))\nnum = num + 1\nend\ncmd = string.gsub(cmd, \"%$%(<%)\", \"$<\")\ncmd = string.gsub(cmd, \"%$%(@%)\", \"$@\")\n \n_p('\\t$(SILENT) %s',cmd)\nend\n_p('')\nend\nend\n_p('-include $(OBJECTS:%%.o=%%.d)')\n_p('ifneq (,$(PCH))')\n_p('  -include $(OBJDIR)/$(notdir $(PCH)).d')\n_p('endif')\nend\nfunction premake.gmake_cpp_header(prj, cc, platforms)\n_p('# %s project makefile autogenerated by GENie', premake.action.current().shortname)\n_p('ifndef config')\n_p('  config=%s', _MAKE.esc(premake.getconfigname(prj.solution.configurations[1], platforms[1], true)))\n_p('endif')\n_p('')\n_p('ifndef verbose')\n_p('  SILENT = @')\n_p('endif')\n_p('')\n_p('SHELLTYPE := msdos')\n_p('ifeq (,$(ComSpec)$(COMSPEC))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstr"
+	"ing /bin,$(SHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(MAKESHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('')\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('  MKDIR = $(SILENT) mkdir -p \"$(1)\"')\n_p('  COPY  = $(SILENT) cp -fR \"$(1)\" \"$(2)\"')\n_p('  RM= $(SILENT) rm -f \"$(1)\"')\n_p('else')\n_p('  MKDIR = $(SILENT) mkdir \"$(subst /,\\\\\\\\,$(1))\" 2> nul || exit 0')\n_p('  COPY  = $(SILENT) copy /Y \"$(subst /,\\\\\\\\,$(1))\" \"$(subst /,\\\\\\\\,$(2))\"')\n_p('  RM    = $(SILENT) del /F \"$(subst /,\\\\\\\\,$(1))\" 2> nul || exit 0')\n_p('endif')\n_p('')\n_p('CC  = %s', cc.cc)\n_p('CXX = %s', cc.cxx)\n_p('AR  = %s', cc.ar)\n_p('')\n_p('ifndef RESCOMP')\n_p('  ifdef WINDRES')\n_p('    RESCOMP = $(WINDRES)')\n_p('  else')\n_p('    RESCOMP = windres')\n_p('  endif')\n_p('endif')\n_p('')\nend\nfunction premake.gmake_cpp_config(prj, cfg, cc)\n_p('ifeq ($(config),%s)', _MAKE.esc(cfg.shortname))\ncpp.platformtools(cfg, cc)\n_p('  ' .. (table.contains(premake.make"
+	".override,\"OBJDIR\") and \"override \" or \"\") ..    'OBJDIR     = %s', _MAKE.esc(cfg.objectsdir))\n_p('  ' .. (table.contains(premake.make.override,\"TARGETDIR\") and \"override \" or \"\") .. 'TARGETDIR  = %s', _MAKE.esc(cfg.buildtarget.directory))\n_p('  ' .. (table.contains(premake.make.override,\"TARGET\") and \"override \" or \"\") ..    'TARGET     = $(TARGETDIR)/%s', _MAKE.esc(cfg.buildtarget.name))\n_p('  DEFINES   +=%s', make.list(cc.getdefines(cfg.defines)))\n_p('  INCLUDES  +=%s', make.list(cc.getincludedirs(cfg.includedirs)))\ncpp.pchconfig(cfg)\ncpp.flags(cfg, cc)\ncpp.linker(prj, cfg, cc)\n_p('  OBJECTS := \\\\')\nfor _, file in ipairs(prj.files) do\nif path.iscppfile(file) then\nif not table.icontains(cfg.excludes, file) then\n_p('\\t$(OBJDIR)/%s.o \\\\'\n, _MAKE.esc(path.trimdots(path.removeext(file)))\n)\nend\nend\nend\n_p('')\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\""
+	", \"\\n\\t\"))\nend\n_p('  endef')\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p('\\t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\nmake.settings(cfg, cc)\n_p('endif')\n_p('')\nend\nfunction cpp.platformtools(cfg, cc)\nlocal platform = cc.platforms[cfg.platform]\nif platform.cc then\n_p('  CC         = %s', platform.cc)\nend\nif platform.cxx then\n_p('  CXX        = %s', platform.cxx)\nend\nif platform.ar then\n_p('  AR         = %s', platform.ar)\nend\nend\nfunction cpp.flags(cfg, cc)\nif cfg.pchheader and not cfg.flags.NoPCH then\n_p('  FORCE_INCLUDE += -include $(OBJDIR)/$(notdir $(PCH))')\nend\nif #cfg.forcedincludes > 0 then\n_p('  FORCE_INCLUDE += -include %s'\n,premake.esc(table.concat(cfg.forcedinclude"
+	"s, \";\")))\nend\n_p('  ALL_CPPFLAGS  += $(CPPFLAGS) %s $(DEFINES) $(INCLUDES)', table.concat(cc.getcppflags(cfg), \" \"))\n_p('  ALL_CFLAGS    += $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)%s', make.list(table.join(cc.getcflags(cfg), cfg.buildoptions, cfg.buildoptions_c)))\n_p('  ALL_CXXFLAGS  += $(CXXFLAGS) $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)%s', make.list(table.join(cc.getcflags(cfg), cc.getcxxflags(cfg), cfg.buildoptions, cfg.buildoptions_cpp)))\n_p('  ALL_OBJCFLAGS += $(CXXFLAGS) $(CFLAGS) $(ALL_CPPFLAGS) $(ARCH)%s', make.list(table.join(cc.getcflags(cfg), cc.getcxxflags(cfg), cfg.buildoptions, cfg.buildoptions_objc)))\n_p('  ALL_RESFLAGS  += $(RESFLAGS) $(DEFINES) $(INCLUDES)%s',\n        make.list(table.join(cc.getdefines(cfg.resdefines),\n                                cc.getincludedirs(cfg.resincludedirs), cfg.resoptions)))\nend\nfunction cpp.linker(prj, cfg, cc)\n_p('  ALL_LDFLAGS   += $(LDFLAGS)%s', make.list(table.join(cc.getlibdirflags(cfg), cc.getldflags(cfg), cfg.linkoptions)))\n_p('  LDDEPS    +=%s', make"
+	".list(_MAKE.esc(premake.getlinks(cfg, \"siblings\", \"fullpath\"))))\n_p('  LIBS      += $(LDDEPS)%s', make.list(cc.getlinkflags(cfg)))\nif cfg.kind == \"StaticLib\" then\nif cfg.platform:startswith(\"Universal\") then\n_p('  LINKCMD    = libtool -o $(TARGET)')\nelse\nif (not prj.options.ArchiveSplit) then\nif cc.llvm then\n_p('  LINKCMD    = $(AR) rcs $(TARGET)')\nelse\n_p('  LINKCMD    = $(AR) -rcs $(TARGET)')\nend\nelse\nif cc.llvm then\n_p('  LINKCMD    = $(AR) qc $(TARGET)')\n_p('  LINKCMD_NDX= $(AR) cs $(TARGET)')\nelse\n_p('  LINKCMD    = $(AR) -qc $(TARGET)')\n_p('  LINKCMD_NDX= $(AR) -cs $(TARGET)')\nend\nend\nend\nelse\nlocal tool = iif(cfg.language == \"C\", \"CC\", \"CXX\")\n_p('  LINKCMD    = $(%s) -o $(TARGET) $(OBJECTS) $(RESOURCES) $(ARCH) $(ALL_LDFLAGS) $(LIBS)', tool)\nend\nend\nfunction cpp.pchconfig(cfg)\nif not cfg.pchheader or cfg.flags.NoPCH then\nreturn\nend\nlocal pch = cfg.pchheader\nfor _, incdir in ipairs(cfg.includedirs) do\nlocal abspath = path.getabsolute(path.join(cfg.project.lo"
+	"cation, incdir))\nlocal testname = path.join(abspath, pch)\nif os.isfile(testname) then\npch = path.getrelative(cfg.location, testname)\nbreak\nend\nend\n_p('  PCH        = %s', _MAKE.esc(pch))\n_p('  GCH        = $(OBJDIR)/$(notdir $(PCH)).gch')\nend\nfunction cpp.pchrules(prj)\n_p('ifneq (,$(PCH))')\n_p('$(GCH): $(PCH)')\n_p('\\t@echo $(notdir $<)')\nlocal cmd = iif(prj.language == \"C\", \"$(CC) -x c-header $(ALL_CFLAGS)\", \"$(CXX) -x c++-header $(ALL_CXXFLAGS)\")\n_p('\\t$(SILENT) %s -MMD -MP $(DEFINES) $(INCLUDES) -o \"$@\" -MF \"$(@:%%.gch=%%.d)\" -c \"$<\"', cmd)\n_p('endif')\n_p('')\nend\nfunction cpp.fileRules(prj)\nfor _, file in ipairs(prj.files or {}) do\nif path.iscppfile(file) then\n_p('$(OBJDIR)/%s.o: %s'\n, _MAKE.esc(path.trimdots(path.removeext(file)))\n, _MAKE.esc(file)\n)\nif (path.isobjcfile(file) and prj.msgcompile_objc) then\n_p('\\t@echo ' .. prj.msgcompile_objc)\nelseif prj.msgcompile then\n_p('\\t@echo ' .. prj.msgcompile)\nelse\n_p('\\t@echo $(notdir $<)')\nend\nif (path.isobjcfile(f"
+	"ile)) then\n_p('\\t$(SILENT) $(CXX) $(ALL_OBJCFLAGS) $(FORCE_INCLUDE) -o \"$@\" -MF $(@:%%.o=%%.d) -c \"$<\"')\nelse\ncpp.buildcommand(path.iscfile(file) and not prj.options.ForceCPP, \"o\")\nend\nfor _, task in ipairs(prj.postcompiletasks or {}) do\n_p('\\t$(SILENT) %s', task)\n_p('')\nend\n_p('')\nelseif (path.getextension(file) == \".rc\") then\n_p('$(OBJDIR)/%s.res: %s', _MAKE.esc(path.getbasename(file)), _MAKE.esc(file))\nif prj.msgresource then\n_p('\\t@echo ' .. prj.msgresource)\nelse\n_p('\\t@echo $(notdir $<)')\nend\n_p('\\t$(SILENT) $(RESCOMP) $< -O coff -o \"$@\" $(ALL_RESFLAGS)')\n_p('')\nend\nend\nend\nfunction cpp.dependencyRules(prj)\nfor _, dependency in ipairs(prj.dependency or {}) do\nfor _, dep in ipairs(dependency or {}) do\nif (dep[3]==nil or dep[3]==false) then\n_p('$(OBJDIR)/%s.o: %s'\n, _MAKE.esc(path.trimdots(path.removeext(path.getrelative(prj.location, dep[1]))))\n, _MAKE.esc(path.getrelative(prj.location, dep[2]))\n)\nelse\n_p('%s: %s'\n, _MAKE.esc(dep[1])\n, _MAKE.esc(path.getrelat"
+	"ive(prj.location, dep[2]))\n)\nend\n_p('')\nend\nend\nend\nfunction cpp.buildcommand(iscfile, objext)\nlocal flags = iif(iscfile, '$(CC) $(ALL_CFLAGS)', '$(CXX) $(ALL_CXXFLAGS)')\n_p('\\t$(SILENT) %s $(FORCE_INCLUDE) -o \"$@\" -MF $(@:%%.%s=%%.d) -c \"$<\"', flags, objext)\nend\n",
 
 	/* actions/make/make_csharp.lua */
 	"local function getresourcefilename(cfg, fname)\nif path.getextension(fname) == \".resx\" then\n    local name = cfg.buildtarget.basename .. \".\"\n    local dir = path.getdirectory(fname)\n    if dir ~= \".\" then \nname = name .. path.translate(dir, \".\") .. \".\"\nend\nreturn \"$(OBJDIR)/\" .. _MAKE.esc(name .. path.getbasename(fname)) .. \".resources\"\nelse\nreturn fname\nend\nend\nfunction premake.make_csharp(prj)\nlocal csc = premake.dotnet\nlocal cfglibs = { }\nlocal cfgpairs = { }\nlocal anycfg\nfor cfg in premake.eachconfig(prj) do\nanycfg = cfg\ncfglibs[cfg] = premake.getlinks(cfg, \"siblings\", \"fullpath\")\ncfgpairs[cfg] = { }\nfor _, fname in ipairs(cfglibs[cfg]) do\nif path.getdirectory(fname) ~= cfg.buildtarget.directory then\ncfgpairs[cfg][\"$(TARGETDIR)/\" .. _MAKE.esc(path.getname(fname))] = _MAKE.esc(fname)\nend\nend\nend\nlocal sources = {}\nlocal embedded = { }\nlocal copypairs = { }\nfor fcfg in premake.project.eachfile(prj) do\nlocal action = csc.getbuildaction(fcfg)\nif action == \"Co"
@@ -199,9 +199,9 @@ const char* builtin_scripts[] = {
 	"(prj.configurations[1]:lower()))\n_p('endif')\n_p('')\n_p('ifndef verbose')\n_p('  SILENT = @')\n_p('endif')\n_p('')\n_p('SHELLTYPE := msdos')\n_p('ifeq (,$(ComSpec)$(COMSPEC))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(SHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(MAKESHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('')\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('  MKDIR = $(SILENT) mkdir -p \"$(1)\"')\n_p('  COPY  = $(SILENT) cp -fR \"$(1)\" \"$(2)\"')\n_p('else')\n_p('  MKDIR = $(SILENT) mkdir \"$(subst /,\\\\\\\\,$(1))\" 2> nul')\n_p('  COPY  = $(SILENT) copy /Y \"$(subst /,\\\\\\\\,$(1))\" \"$(subst /,\\\\\\\\,$(2))\"')\n_p('endif')\n_p('')\n_p('ifndef CSC')\n_p('  CSC=%s', csc.getcompilervar(prj))\n_p('endif')\n_p('')\n_p('ifndef RESGEN')\n_p('  RESGEN=resgen')\n_p('endif')\n_p('')\nlocal platforms = premake.filterplatforms(prj.solution, premake[_OPTIONS.cc].platforms)\ntable.insert(platforms, 1, \"\")\nfor cfg in premake.each"
 	"config(prj) do\npremake.gmake_cs_config(cfg, csc, cfglibs)\nend\n_p('# To maintain compatibility with VS.NET, these values must be set at the project level')\n_p('TARGET     := $(TARGETDIR)/%s', _MAKE.esc(prj.buildtarget.name))\n_p('FLAGS      += /t:%s %s', csc.getkind(prj):lower(), table.implode(_MAKE.esc(prj.libdirs), \"/lib:\", \"\", \" \"))\n_p('REFERENCES += %s', table.implode(_MAKE.esc(premake.getlinks(prj, \"system\", \"basename\")), \"/r:\", \".dll\", \" \"))\n_p('')\n_p('SOURCES := \\\\')\nfor _, fname in ipairs(sources) do\n_p('\\t%s \\\\', _MAKE.esc(path.translate(fname)))\nend\n_p('')\n_p('EMBEDFILES := \\\\')\nfor _, fname in ipairs(embedded) do\n_p('\\t%s \\\\', getresourcefilename(prj, fname))\nend\n_p('')\n_p('COPYFILES += \\\\')\nfor target, source in pairs(cfgpairs[anycfg]) do\n_p('\\t%s \\\\', target)\nend\nfor target, source in pairs(copypairs) do\n_p('\\t%s \\\\', target)\nend\n_p('')\n_p('SHELLTYPE := msdos')\n_p('ifeq (,$(ComSpec)$(COMSPEC))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p"
 	"('ifeq (/bin,$(findstring /bin,$(SHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(MAKESHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('')\n_p('.PHONY: clean prebuild prelink')\n_p('')\n_p('all: $(TARGETDIR) $(OBJDIR) prebuild $(EMBEDFILES) $(COPYFILES) prelink $(TARGET)')\n_p('')\n_p('$(TARGET): $(SOURCES) $(EMBEDFILES) $(DEPENDS)')\n_p('\\t$(SILENT) $(CSC) /nologo /out:$@ $(FLAGS) $(REFERENCES) $(SOURCES) $(patsubst %%,/resource:%%,$(EMBEDFILES))')\n_p('\\t$(POSTBUILDCMDS)')\n_p('')\n_p('$(TARGETDIR):')\npremake.make_mkdirrule(\"$(TARGETDIR)\")\n_p('$(OBJDIR):')\npremake.make_mkdirrule(\"$(OBJDIR)\")\n_p('clean:')\n_p('\\t@echo Cleaning %s', prj.name)\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('\\t$(SILENT) rm -f $(TARGETDIR)/%s.* $(COPYFILES)', prj.buildtarget.basename)\n_p('\\t$(SILENT) rm -rf $(OBJDIR)')\n_p('else')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(TARGETDIR)/%s.*) del $(subst /,\\\\\\\\,$(TARGETDIR)/%s.*)', prj.buildtarget.basename, prj.buildtarget.b"
-	"asename)\nfor target, source in pairs(cfgpairs[anycfg]) do\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,%s) del $(subst /,\\\\\\\\,%s)', target, target)\nend\nfor target, source in pairs(copypairs) do\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,%s) del $(subst /,\\\\\\\\,%s)', target, target)\nend\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\\\\\,$(OBJDIR))')\n_p('endif')\n_p('')\n_p('prebuild:')\n_p('\\t$(PREBUILDCMDS)')\n_p('')\n_p('prelink:')\n_p('\\t$(PRELINKCMDS)')\n_p('')\n_p('# Per-configuration copied file rules')\nfor cfg in premake.eachconfig(prj) do\n_p('ifneq (,$(findstring %s,$(config)))', _MAKE.esc(cfg.name:lower()))\nfor target, source in pairs(cfgpairs[cfg]) do\npremake.make_copyrule(source, target)\nend\n_p('endif')\n_p('')\nend\n_p('# Copied file rules')\nfor target, source in pairs(copypairs) do\npremake.make_copyrule(source, target)\nend\n_p('# Embedded file rules')\nfor _, fname in ipairs(embedded) do \nif path.getextension(fname) == \".resx\" then\n"
-	"_p('%s: %s', getresourcefilename(prj, fname), _MAKE.esc(fname))\n_p('\\t$(SILENT) $(RESGEN) $^ $@')\nend\n_p('')\nend\nend\nfunction premake.gmake_cs_config(cfg, csc, cfglibs)\n_p('ifneq (,$(findstring %s,$(config)))', _MAKE.esc(cfg.name:lower()))\n_p('  TARGETDIR  := %s', _MAKE.esc(cfg.buildtarget.directory))\n_p('  OBJDIR     := %s', _MAKE.esc(cfg.objectsdir))\n_p('  DEPENDS    := %s', table.concat(_MAKE.esc(premake.getlinks(cfg, \"dependencies\", \"fullpath\")), \" \"))\n_p('  REFERENCES := %s', table.implode(_MAKE.esc(cfglibs[cfg]), \"/r:\", \"\", \" \"))\n_p('  FLAGS      += %s %s', table.implode(cfg.defines, \"/d:\", \"\", \" \"), table.concat(table.join(csc.getflags(cfg), cfg.buildoptions), \" \"))\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p('\\"
-	"t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('endif')\n_p('')\nend\n",
+	"asename)\nfor target, source in pairs(cfgpairs[anycfg]) do\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,%s) del $(subst /,\\\\\\\\,%s)', target, target)\nend\nfor target, source in pairs(copypairs) do\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,%s) del $(subst /,\\\\\\\\,%s)', target, target)\nend\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\\\\\,$(OBJDIR))')\n_p('endif')\n_p('')\n_p('prebuild:')\n_p('\\t$(PREBUILDCMDS)')\n_p('')\n_p('prelink:')\n_p('\\t$(PRELINKCMDS)')\n_p('')\n_p('# Per-configuration copied file rules')\nfor cfg in premake.eachconfig(prj) do\n_p('ifneq (,$(findstring %s,$(config)))', _MAKE.esc(cfg.name:lower()))\nfor target, source in pairs(cfgpairs[cfg]) do\npremake.make_copyrule(source, target)\nend\n_p('endif')\n_p('')\nend\n_p('# Copied file rules')\nfor target, source in pairs(copypairs) do\npremake.make_copyrule(source, target)\nend\n_p('# Embedded file rules')\nfor _, fname in ipairs(embedded) do \nif path.getextension(fname) == \".resx\" then"
+	"\n_p('%s: %s', getresourcefilename(prj, fname), _MAKE.esc(fname))\n_p('\\t$(SILENT) $(RESGEN) $^ $@')\nend\n_p('')\nend\nend\nfunction premake.gmake_cs_config(cfg, csc, cfglibs)\n_p('ifneq (,$(findstring %s,$(config)))', _MAKE.esc(cfg.name:lower()))\n_p('  TARGETDIR  := %s', _MAKE.esc(cfg.buildtarget.directory))\n_p('  OBJDIR     := %s', _MAKE.esc(cfg.objectsdir))\n_p('  DEPENDS    := %s', table.concat(_MAKE.esc(premake.getlinks(cfg, \"dependencies\", \"fullpath\")), \" \"))\n_p('  REFERENCES := %s', table.implode(_MAKE.esc(cfglibs[cfg]), \"/r:\", \"\", \" \"))\n_p('  FLAGS      += %s %s', table.implode(cfg.defines, \"/d:\", \"\", \" \"), table.concat(table.join(csc.getflags(cfg), cfg.buildoptions), \" \"))\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p"
+	"('\\t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n_p('endif')\n_p('')\nend\n",
 
 	/* actions/vstudio/_vstudio.lua */
 	"premake.vstudio = { }\nlocal toolsets = {\nvs2010 = \"v100\",\nvs2012 = \"v110\",\nvs2013 = \"v120\",\nvs2015 = \"v140\"\n}\npremake.vstudio.toolset = toolsets[_ACTION] or \"unknown?\"\npremake.vstudio.splashpath = ''\nlocal vstudio = premake.vstudio\nvstudio.platforms = {\nany     = \"Any CPU\",\nmixed   = \"Mixed Platforms\",\nNative  = \"Win32\",\nx86     = \"x86\",\nx32     = \"Win32\",\nx64     = \"x64\",\nPS3     = \"PS3\",\nXbox360 = \"Xbox 360\",\nARM     = \"ARM\",\nOrbis= \"Orbis\"\n}\nfunction vstudio.arch(prj)\nif (prj.language == \"C#\") then\nreturn \"Any CPU\"\nelse\nreturn \"Win32\"\nend\nend\nfunction vstudio.iswinrt()\nreturn vstudio.storeapp ~= nil and vstudio.storeapp ~= ''\nend\nfunction vstudio.buildconfigs(sln)\nlocal cfgs = { }\nlocal platforms = premake.filterplatforms(sln, vstudio.platforms, \"Native\")\nlocal hascpp    = premake.hascppproject(sln)\nlocal hasdotnet = premake.hasdotnetproject(sln)\nif hasdotnet and (_ACTION > \"vs2008\" or hascpp) then\ntable.insert(platforms, 1, \"mix"
